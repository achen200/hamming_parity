101011000 //i = 0
101100000 //j = 0
010000000 //
010000000 //Initialize upper_bits, lower_bits, i, j //
000100100 //$1 = data_mem[j+1]
100110001 //$6 = $1    or $6 = upper_bits
100111001 //temp_u = upper_bits
010000000 //
010000000 //
000100000 //$1 = data_mem[j]
100010001 //temp_l = lower_bits
010000000 //
010000000 //
010000000 //Calculate p8 and MSW at mem[j + 31] //
110111100 //temp_u << 4 We want << 5 but shifts limited to 4 bits
110111111 //temp_u << 1
110010011 //temp_l >> 4
110010111 //temp_l << 1
010011100 //$8 = temp_u + temp_l or to_store = temp_u + temp_l
111111010 //$7 = p8
010011100 //to_store += p8
100111010 //$7 = $2
010000000 //
010000000 //Calculate j + 31//
101010000 //$2 = 0    or x = 0
010011101 //$2 += 4    or x = 4
110010100 //$2 /= 4    or x = 32
010010011 //$2 -= 1    or x = 31
100101100 //$5 = j
010011000 //$2 = j + 31
100101001 //$5 = temp_l   make reg5 hold lower_bits
010000000 //
010000000 //Store MSW into mem[j+31]//
100111001 //$1 = MSW
000010001 //mem[j+31] = to_store
010000000 //
010000000 //Isolate p8//
110111100 //
110111101 //$7 = (p8)000_0000
110111011 //
110111001 //$7 = 0000_00(p8)0
010000000 //
010000000 //Calculate p4//
110110111 //upper_bits << 1
110101011 //
110101010 //$5 = b8
010111000 //$6 = 0000_b11:b8
000100000 //$1 = lower_bits
100001101 //$5 = lower_bits
110101000 //$5 = 0_b8:b2
110101100 //
110101111 //$5 = (b4:b2)0_0000
010111000 //$6 = (b4:b2)0_b11:b8
111110110 //$6 = p4
010000000 //
010000000 //Move p4 into reg7//
010111100 //$6 = 0000_00p8p4
100111110 //$7 = 0000_00p8p4
010000000 //
010000000 //Calculate p2//
000100100 //$1 = upper_bits
110001000 //$1 = 0000_00_b11_b10
111101001 //Store reduction XOR of b11,b10 into $5
000100100 //$1 = lower_bits
010000000 //Create bitmask for p2 (0110_1101)
101110000 //$6 = 0000_0000
010111001 //$6 = 0000_0011
110110101 //$6 = 0001_1000
010111001 //$6 = 0001_1011
110110110 //$6 = 0110_1100
010110001 //$6 = 0110_1101
101110001 //$6 = x (bitmask applied to lower_bits)
111110110 //$6 = ^x
010000000 //Calculate final p2
110101111 //$5 = 0000_00(b11^b10)0
010111000 //$6 = 0000_00(b11^b10)(^x)
111110110 //$6 = 0000_000(p2)
010000000 //
010000000 //Save p2 into reg7//
110111111 //$7 = 0000_0(p8)(p4)0
010111100 //$6 = 0000_0(p8)(p4)(p2)
100111110 //$7 = 0000_0(p8)(p4)(p2)
010000000 //
010000000 //Calculate P1//
010000000 //Create upper_bits bitmask (0000_0101)
101010000 //$2 = 0000_0000
010011101 //$2 = 0000_0100
010010001 //$2 = 0000_0101
000100100 //$1 = upper_bits
101010001 //$2 = 0000_0(b11)0(b9)
111010101 //$5 = 0000_000(b11^b9)
010000000 //Create lower_bits bitmask (0101_1011)
101110000 //$6 = 0000_0000
010110001 //$6 = 0000_0001
110110101 //$6 = 0000_1000
010111001 //$6 = 0000_1011
110110101 //$6 = 0101_1000
010111001 //$6 = 0101_1011
000100000 //$1 = lower_bits
101110001 //$6 = 0(b7)0(b5)_(b4)0(b2)(b1) = x
111110110 //$6 = 0000_000(^x)
010000000 //
010000000 //Finalize p1 calculations//
110110111 //$6 = 0000_00(^x)0
010111000 //$6 = 0000_00(^x)(b11^b9)
111110110 //$6 = p1
010000000 //
010000000 //Save p1 to reg7//
110111111 //$7 = 0000_(p8)(p4)(p2)0
010111100 //$6 = 0000_(p8)(p4)(p2)(p1)
100111110 //$7 = 0000_(p8)(p4)(p2)(p1)
010000000 //
010000000 //Calculate p0//
111110110 //$6 = 0000_000(p8^p4^p2^p1)
111001101 //$5 = 0000_000^(b8:b1)
000100100 //$1 = upper_bits
111001001 //$1 = 0000_000^(upper_bits)
110110111 //$6 = 0000_00(p8^p4^p2^p1)0
010111000 //$6 = 0000_00(p8^p4^p2^p1)(^b8:b1)
110110111 //$6 = 0000_0(p8^p4^p2^p1)(^b8:b1)0
010110000 //$6 = 0000_0(p8^p4^p2^p1)(^b8:b1)(^b11:b9)
111110110 //$6 = p0
010000000 //
010000000 //Store p0 in reg7//
110111111 //$7 = 000(p8)_(p4)(p2)(p1)0
010111100 //$6 = 000(p8)_(p4)(p2)(p1)(p0)
100111110 //
010000000 //
010000000 //Calculate LSW//
000100000 //$1 = lower_bits
110001000 //$1 = 0b8:b2
110001100 //$1 = b5:b2_0000
110001111 //$1 = b4:b20_0000
110110100 //$6 = (p4)(p2)(p1)(p0)_0000
110110010 //$6 = 000(p4)_(p2)(p1)(p0)0
100111110 //$7 = 000(p4)_(p2)(p1)(p0)0
110110011 //$6 = 0000_000(p4)
110110100 //$6 = 000(p4)_0000
010110000 //$6 = b4:b2(p4)_0000
010000000 //Create bitmask for b1
000100000 //$1 = b8:b1
101010000 //$2 = 0
010010001 //$2 = 0000_0001
101001010 //$1 = 0000_000b1
110001101 //$1 = 0000_(b1)000
010110000 //$6 = b4:b2(p4)_(b1)000
010000000 //Create bitmask for p2:p0
110111000 //$7 = 0000_(p4)(p2)(p1)(p0)
101010000 //$2 = 0000_0000
010011001 //$2 = 0000_0011
110010111 //$2 = 0000_0110
010010001 //$2 = 0000_0111
101111010 //$7 = 0000_0(p2)(p1)(p0)
010111100 //$6 = LSW
100001110 //$1 = 4:b2(p4)_b1(p2)(p1)(p0)
010000000 //
010000000 //Calculate j+30//
101010000 //$2 = 0    or x = 0
010011101 //$2 += 4    or x = 4
110010100 //$2 /= 4    or x = 32
010010111 //$2 -= 2    or x = 30
100101100 //$5 = j
010011000 //$2 = j + 30
000010001 //mem[j+30] = $1
010000000 //
010000000 //Finish Loop//
010100101 //j+=2
100010011 //$2 = i
010010001 //i++
100011010 //$1 = i
010000000 //Setup branch operation
101010000 //$2 = 0000_0000 (setup comparison to take the branch)
010011101 //$2 = 4
110010110 //$2 = 16
010010111 //$2 = 14
101110000 //setup reg6 to contain destination
010111101 //$6 = 5
010110001 //Destination address is of PC 0x05
100110111 //Move $6 to $7, and setup alternate destination if i == 14
110110110 //$6 = 20
010111101 //$6 = 24
110110101 //$6 = 24/8 = 192
001010011 //Branch to DONE if i == 14
001000000 //
011000110 //
011000111 //Else go to beginning of loop
010000000 //
010000000 //NO-OP//
010000000 //
010000000 //
010000000 //
010000000 //
010000000 //
010000000 //DONE:   //Raise done flag
